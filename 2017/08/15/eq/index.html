<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>EQ曲线的过程 | 逻辑思维 | 老黄</title>

  
  <meta name="author" content="老黄">
  

  
  <meta name="description" content="踩过的坑，你就得跨过去，不然你就是个傻子">
  

  
  
  <meta name="keywords" content="闲聊">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="EQ曲线的过程"/>

  <meta property="og:site_name" content="逻辑思维"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="逻辑思维" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">逻辑思维</a>
    </h1>
    <p class="site-description">老黄</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">目录</a></li>
      
        <li><a href="/project">项目</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>EQ曲线的过程</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/15/eq/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-15T06:37:28.000Z">
          2017-08-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>  这是1次教训，曾经以为所有事情只要坚持不懈就会得到结果。但在这件事情上，没有相关的技术沉淀，浪费再多时间也不讨好。<br>SO，最终以猪八戒告终，很down。</p>
<h2 id="EQ曲线是什么？"><a href="#EQ曲线是什么？" class="headerlink" title="EQ曲线是什么？"></a>EQ曲线是什么？</h2><img src="/2017/08/15/eq/eq.png" alt="eq" title="eq">
<p> EQ英文全称Equaliser，中文也就是均衡器的意思。它的基本作用是通过对声音某一个或多个频段进行增益或衰减，从而达到调整音色的目的。<br>    EQ通常包括以下三个参数：Frequency，频率――这是用于设定你要进行调整的频率点的参数；Gain，增益――用于调整在你设定好的F值上进行增益或衰减的参数；Quantize――用于设定你要进行增益或衰减的频段“宽度”的参数。在这里，要注意是：当你设定的Q值越小的时候，你所处理的频段就越宽，而当你设定的Q值越大的时候，你所处理的频段就越窄。</p>
<h2 id="如何绘制EQ曲线？"><a href="#如何绘制EQ曲线？" class="headerlink" title="如何绘制EQ曲线？"></a>如何绘制EQ曲线？</h2><p>以我的例子来说，每个DSP的EQ都是由不同的滤波器组成的，我们的是30段Peaking Filter。</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>先得到 滤波器的系数<br><pre><code> 
   		Peaking滤波器
&lt;param name=&quot;fc&quot;&gt;&lt;&#x2F;param&gt;
&lt;param name=&quot;g&quot;&gt;&lt;&#x2F;param&gt;
&lt;param name=&quot;q&quot;&gt;&lt;&#x2F;param&gt;
&lt;param name=&quot;len&quot;&gt;&lt;&#x2F;param&gt;
&lt;param name=&quot;x_out&quot;&gt;&lt;&#x2F;param&gt;
&lt;param name=&quot;y_out&quot;&gt;&lt;&#x2F;param&gt;
     public void PeakingFilter(double fc, double g, double q, int len, out double[] x_out, out double[] y_out)
     {
         &#x2F;&#x2F; Peaking滤波器系数
         double A = Math.Pow(10, g &#x2F; 40);
         double w = 2 * Math.PI * fc &#x2F; Fs;
         double alpha = Math.Sin(w) &#x2F; 2 &#x2F; q;
         double dG = 1 &#x2F; (1 + alpha &#x2F; A);

         double[] b = new double[3];
         double[] a = new double[3];
         b[0] = dG * (1 + alpha * A);
         b[1] = -2 * dG * Math.Cos(w);
         b[2] = dG * (1 - alpha * A);

         a[0] = 1;
         a[1] = b[1];
         a[2] = dG * (1 - alpha &#x2F; A);

      
     }
     </code></pre></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>计算数字滤波器的频率响应</p>
<pre><code> &#x2F;&#x2F;num 是数字滤波器的分子多项式系数 
 &#x2F;&#x2F;num 是数字滤波器的分子多项式系数
  &#x2F;&#x2F;den 是数字滤波器的分母多项式系数
  &#x2F;&#x2F;num_order 是分子多项式的阶数
  &#x2F;&#x2F;den_order 是分母多项式的阶数
  &#x2F;&#x2F;len 为，频率响应的取样点数
    &#x2F;&#x2F;sign = 0 时
   &#x2F;&#x2F;x_out 为频率响应的实部
&#x2F;&#x2F; y_out 为频率响应的虚部
sign = 1 时，x_out 为频率响应的模， y_out 为频率响应的幅角
   sign = 2 时，x_out 为以 dB 为单位的频率响应， y_out 为频率响应的幅角
   
        public void FilterGain(double[] num, double[] den, int num_order, int den_order, int len, int sign,
                 out double[] x_out, out double[] y_out)
        {
            x_out = new double[len];
            y_out = new double[len];

            int i, k;
            double zr, zi;
            double re, im;
            double ar, ai, br, bi;
            double numr, numi;
            double de, temp;
            double freq;
            for (k = 0; k &lt; len; k++)
            {
                freq = 0.5 * k &#x2F; (len - 1);
                zr = Math.Cos(-2.0 * Math.PI * freq);
                zi = Math.Sin(-2.0 * Math.PI * freq);
                br = 0.0;
                bi = 0.0;
                for (i = num_order; i &gt; 0; i--)
                {
                    re = br;
                    im = bi;
                    br = (re + num[i]) * zr - im * zi;
                    bi = (re + num[i]) * zi + im * zr;
                }
                ar = 0.0;
                ai = 0.0;
                for (i = den_order; i &gt; 0; i--)
                {
                    re = ar;
                    im = ai;
                    ar = (re + den[i]) * zr - im * zi;
                    ai = (re + den[i]) * zi + im * zr;
                }
                br = br + num[0];
                ar = ar + 1.0;
                numr = ar * br + ai * bi;
                numi = ar * bi - ai * br;
                de = ar * ar + ai * ai;
                x_out[k] = numr &#x2F; de;
                y_out[k] = numi &#x2F; de;
                switch (sign)
                {
                    case 1:
                        temp  = x_out[k] * x_out[k] + y_out[k] * y_out[k];
                        y_out[k] = Math.Atan2(y_out[k], x_out[k]);
                        x_out[k] = Math.Sqrt(temp);
                        break;
                    case 2:
                        temp = x_out[k] * x_out[k] + y_out[k] * y_out[k];
                        y_out[k] = Math.Atan2(y_out[k], x_out[k]);
                        x_out[k] = 10 * Math.Log10(temp);
                        break;
                    default:
                        break;
                }
            }
        }</code></pre>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>绘制曲线</p>
  <pre><code>public void DrawBack(Graphics g, myPoint[] line)
       {
           try
           {
               Pen p = new Pen(Color.Gray , 1);&#x2F;&#x2F;定义画笔 
               SolidBrush brush = new SolidBrush(Color.Gray );
               Font myFont = new Font(&quot;宋体&quot;, 10, FontStyle.Regular);

               &#x2F;&#x2F;画边框
               int bx = 50;
               int by = 40;
               g.DrawRectangle(p, bx, by, panel_Pic.Width - 2 * bx, panel_Pic.Height - 2 * by);

               &#x2F;&#x2F; 横线
               int ay = (panel_Pic.Height - 2 * by) &#x2F; 8;
               for (int i = 1; i &lt; 8; i++)
               {
                   g.DrawLine(p, bx, by + ay * i, panel_Pic.Width - bx, by + ay * i);
               }
               for (int i = 0; i &lt; 5; i++)
               { 
                   g.DrawString(db[i], myFont, brush, bx - 40, by + ay * i * 2 - 5);
               }

               &#x2F;&#x2F; 竖线
               double ax = (panel_Pic.Width  - 2.0 * bx) &#x2F; (Math.Log(nEnd) - Math.Log(nStart));   &#x2F;&#x2F; X轴使用对数轴 非均匀
               for (int i = 0; i &lt; nl.Count(); i++)
               {
                   int x = (int)(bx + ax * (Math.Log(nl[i]) - Math.Log(nStart)));

                   g.DrawLine(p, x, by, x, panel_Pic.Height - by);
               }
               for (int i = 0; i &lt; nf.Count(); i++)
               {
                   int x = (int)(bx + ax * (Math.Log(nf[i]) - Math.Log(nStart)));

                   g.DrawString(nf[i].ToString(), myFont, brush, x - 5, panel_Pic.Height - by + 10);
                   
               }

               &#x2F;&#x2F; 画曲线
               double cy = (panel_Pic.Height - 2 * by) &#x2F; 20.0;
               p = new Pen(Color.Sienna  , 2);&#x2F;&#x2F;定义画笔
               for (int i = 0; i &lt; nLen; i++)
               {
                   if (pLine[i].x &gt;= nStart  &amp;&amp; pLine[i].x &lt;= nEnd &amp;&amp; pLine[i - 1].y &gt;= -10 &amp;&amp; pLine[i - 1].y &lt;= 10)
                   {
                       int x0 = (int)(bx + ax * (Math.Log(pLine[i - 1].x) - Math.Log(nStart)));
                       int x1 = (int)(bx + ax * (Math.Log(pLine[i].x) - Math.Log(nStart)));
                       int y0 = (int)(by + cy * (10 - pLine[i - 1].y));
                       int y1 = (int)(by + cy * (10 - pLine[i].y));
                       g.DrawLine(p, x0, y0, x1, y1);
                   }
               }

           }
           catch (Exception ex)
           { }
       }



</code></pre>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/闲聊/">闲聊</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 老黄
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>